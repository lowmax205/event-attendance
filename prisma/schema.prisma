generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model SecurityLog {
  id        String   @id
  userId    String?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  action    String
  metadata  Json?
  User      User?    @relation(fields: [userId], references: [id])

  @@index([action, createdAt])
  @@index([createdAt])
  @@index([userId, createdAt])
}

model Session {
  id           String   @id
  userId       String
  refreshToken String   @unique
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())
  expiresAt    DateTime
  isRevoked    Boolean  @default(false)
  User         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([refreshToken])
  @@index([userId])
}

model User {
  id                  String        @id
  email               String        @unique
  passwordHash        String
  role                Role          @default(Student)
  accountStatus       String        @default("active")
  emailVerified       Boolean       @default(false)
  createdAt           DateTime      @default(now())
  lastLoginAt         DateTime?
  firstName           String
  lastName            String
  SecurityLog         SecurityLog[]
  Session             Session[]
  UserProfile         UserProfile?
  createdEvents       Event[]       @relation("EventCreator")
  attendances         Attendance[]
  verifiedAttendances Attendance[]  @relation("AttendanceVerifier")

  @@index([email])
}

model UserProfile {
  id            String   @id
  userId        String   @unique
  section       String?
  department    String
  updatedAt     DateTime
  contactNumber String?
  createdAt     DateTime @default(now())
  studentId     String   @unique
  yearLevel     Int
  User          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum Role {
  Student
  Moderator
  Administrator
}

model Event {
  id                 String       @id @default(cuid())
  name               String
  description        String?      @db.Text
  startDateTime      DateTime
  endDateTime        DateTime
  venueLatitude      Float
  venueLongitude     Float
  venueName          String
  venueAddress       String?
  checkInBufferMins  Int          @default(30)
  checkOutBufferMins Int          @default(30)
  qrCodeUrl          String?
  qrCodePayload      String       @unique
  status             EventStatus  @default(Active)
  createdById        String
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt

  createdBy          User         @relation("EventCreator", fields: [createdById], references: [id])
  attendances        Attendance[]

  @@index([startDateTime, endDateTime])
  @@index([status])
  @@index([createdById])
}

enum EventStatus {
  Active
  Completed
  Cancelled
}

model Attendance {
  id                 String             @id @default(cuid())
  eventId            String
  userId             String
  submittedAt        DateTime           @default(now())
  latitude           Float
  longitude          Float
  distanceFromVenue  Float
  frontPhotoUrl      String
  backPhotoUrl       String
  signatureUrl       String
  verificationStatus VerificationStatus @default(Pending)
  verifiedById       String?
  verifiedAt         DateTime?
  disputeNote        String?            @db.Text
  ipAddress          String?
  userAgent          String?

  event              Event              @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user               User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  verifiedBy         User?              @relation("AttendanceVerifier", fields: [verifiedById], references: [id])

  @@unique([eventId, userId])
  @@index([userId, submittedAt])
  @@index([eventId, verificationStatus])
  @@index([verificationStatus])
}

enum VerificationStatus {
  Pending
  Approved
  Rejected
  Disputed
}
